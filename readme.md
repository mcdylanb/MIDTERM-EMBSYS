# TOPICS
- TIMER1
- ADC
- UART

## Prerequisites 
```c
include <xc.h>

// Configuration bits
#pragma config FOSC = XT   // Oscillator Selection bits (XT oscillator)
#pragma config WDTE = OFF  // Watchdog Timer Enable bit (WDT disabled)
#pragma config PWRTE = ON  // Power-up Timer Enable bit (PWRT enabled)
#pragma config BOREN = ON  // Brown-out Reset Enable bit (BOR enabled)
#pragma config LVP = OFF   // Low Voltage Programming Enable bit (disabled)
#pragma config CPD = OFF   // Data EEPROM Memory Code Protection bit (disabled)
#pragma config WRT = OFF   // Flash Program Memory Write Enable bits (Write protection off)
#pragma config CP = OFF    // Flash Program Memory Code Protection bit (disabled)
```

# TIMER1
```c
void interrupt ISR(void)
{
    GIE = 0; // disable all unmasked interrupts (INTCON reg)
    if(TMR1IF==1) // checks Timer1 interrupt flag
    {
        TMR1IF = 0; // clears interrupt flag
        TMR1 = 0x0BDC; // timer will start counting at 0x0BDC (3036)
        RA0 = RA0^1; // toggles the LED at RA0
    }
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
}

void main(void)
{
    ADCON1 = 0x6; // set all pins in PORTA as digital I/O
    TRISA = 0x00; // sets all of PORTA to output
    RA0 = 0; // initialize RA0 to 0 (LED off)
    T1CON = 0x30; // 1:8 prescaler, internal clock, Timer1 off
    TMR1IE = 1; // enable Timer1 overflow interrupt (PIE1 reg)
    TMR1IF = 0; // reset interrupt flag (PIR1 reg)
    PEIE = 1; // enable all peripheral interrupt (INTCON reg)
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
    TMR1 = 0x0BDC; // counter starts counting at 0x0BDC (3036)
    TMR1ON = 1; // Turns on Timer1 (T1CON reg)
    for(;;) // foreground routine
    {
    }
}
```

## TIMER 2
- does not generate interrupt upon overflow
- generates an interrupt upon value equal to the period register (PR2) and resets to `00h`
- PR2 can be read or written to and is also an 8-bit register

```c
void interrupt ISR(void)
{
    GIE = 0; // disable all unmasked interrupts (INTCON reg)
    if(TMR2IF==1) // checks Timer2 interrupt flag (TMR2=PR2)
        {
        TMR2IF = 0; // clears interrupt flag
        RA0 = RA0^1; // toggles the output signal at RA0
        }
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
}

void main(void)
{
    ADCON1 = 0x6; // set all pins in PORTA as digital I/O
    TRISA = 0x00; // sets all of PORTA to output
    RA0 = 0; // initialize RA0 to 0
    T2CON = 0x01; // 1:4 prescaler, Timer2 off
    TMR2IE = 1; // enable Timer2/PR2 match interrupt (PIE1 reg)
    TMR2IF = 0; // reset interrupt flag (PIR1 reg)
    PEIE = 1; // enable all peripheral interrupt (INTCON reg)
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
    PR2 = 0x7D; // match value for TMR2(125)at half cycle
    TMR2ON = 1; // Turns on Timer2 (T2CON reg)
    for(;;) // foreground routine
    {
    }
}
```

## CCP MODULE
- 2 ccp modules: CCP1 and CCP2
- both are identical in operation, with the exception being the operation of the special event trigger

### CCP1 Module
- Capture/Compare/PWM Register 1 (CCPR1) is comprised of two 8-bit registers: CCPR1L and CCPR1H
- CCP1CON register controls the operation of CCP1.
- special event trigger is generated by a compare match and will reset Timer1

### CCP2 Module
- same as CCP1 two 8-bit registers CCPR2L and CCPR2H
CCP2CON register controls the operation of CCP2
- special event trigger is generated by a compare match and will reset Timer1 and start an A/D conversion