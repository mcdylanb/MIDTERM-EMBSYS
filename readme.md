# TOPICS
- [x] TIMER1
    - [ ] Practice 
- ADC
- UART

## Prerequisites 
```c
include <xc.h>

// Configuration bits
#pragma config FOSC = XT   // Oscillator Selection bits (XT oscillator)
#pragma config WDTE = OFF  // Watchdog Timer Enable bit (WDT disabled)
#pragma config PWRTE = ON  // Power-up Timer Enable bit (PWRT enabled)
#pragma config BOREN = ON  // Brown-out Reset Enable bit (BOR enabled)
#pragma config LVP = OFF   // Low Voltage Programming Enable bit (disabled)
#pragma config CPD = OFF   // Data EEPROM Memory Code Protection bit (disabled)
#pragma config WRT = OFF   // Flash Program Memory Write Enable bits (Write protection off)
#pragma config CP = OFF    // Flash Program Memory Code Protection bit (disabled)
```

# TIMER1
```c
void interrupt ISR(void)
{
    GIE = 0; // disable all unmasked interrupts (INTCON reg)
    if(TMR1IF==1) // checks Timer1 interrupt flag
    {
        TMR1IF = 0; // clears interrupt flag
        TMR1 = 0x0BDC; // timer will start counting at 0x0BDC (3036)
        RA0 = RA0^1; // toggles the LED at RA0
    }
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
}

void main(void)
{
    ADCON1 = 0x6; // set all pins in PORTA as digital I/O
    TRISA = 0x00; // sets all of PORTA to output
    RA0 = 0; // initialize RA0 to 0 (LED off)
    T1CON = 0x30; // 1:8 prescaler, internal clock, Timer1 off
    TMR1IE = 1; // enable Timer1 overflow interrupt (PIE1 reg)
    TMR1IF = 0; // reset interrupt flag (PIR1 reg)
    PEIE = 1; // enable all peripheral interrupt (INTCON reg)
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
    TMR1 = 0x0BDC; // counter starts counting at 0x0BDC (3036)
    TMR1ON = 1; // Turns on Timer1 (T1CON reg)
    for(;;) // foreground routine
    {
    }
}
```

## TIMER 2
- does not generate interrupt upon overflow
- generates an interrupt upon value equal to the period register (PR2) and resets to `00h`
- PR2 can be read or written to and is also an 8-bit register

```c
void interrupt ISR(void)
{
    GIE = 0; // disable all unmasked interrupts (INTCON reg)
    if(TMR2IF==1) // checks Timer2 interrupt flag (TMR2=PR2)
        {
        TMR2IF = 0; // clears interrupt flag
        RA0 = RA0^1; // toggles the output signal at RA0
        }
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
}

void main(void)
{
    ADCON1 = 0x6; // set all pins in PORTA as digital I/O
    TRISA = 0x00; // sets all of PORTA to output
    RA0 = 0; // initialize RA0 to 0
    T2CON = 0x01; // 1:4 prescaler, Timer2 off
    TMR2IE = 1; // enable Timer2/PR2 match interrupt (PIE1 reg)
    TMR2IF = 0; // reset interrupt flag (PIR1 reg)
    PEIE = 1; // enable all peripheral interrupt (INTCON reg)
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
    PR2 = 0x7D; // match value for TMR2(125)at half cycle
    TMR2ON = 1; // Turns on Timer2 (T2CON reg)
    for(;;) // foreground routine
    {
    }
}
```

## CCP MODULE
- 2 ccp modules: CCP1 and CCP2
- both are identical in operation, with the exception being the operation of the special event trigger

### CCP1 Module
- Capture/Compare/PWM Register 1 (CCPR1) is comprised of two 8-bit registers: CCPR1L and CCPR1H
- CCP1CON register controls the operation of CCP1.
- special event trigger is generated by a compare match and will reset Timer1

### CCP2 Module
- same as CCP1 two 8-bit registers CCPR2L and CCPR2H
CCP2CON register controls the operation of CCP2
- special event trigger is generated by a compare match and will reset Timer1 and start an A/D conversion

### Capture Mode
- captures the 16bit alue of the TMR1 register when an event occurs on pin RC2/CCP1
- Event:
    - every falling edge
    - every rising edge
    - every 4th rising edge
    - every 16th rising edge
- event type is configured by control bits CCP1M3:CCP1M0

### EXAMPLE (CAPTURE)
```c
void interrupt ISR(void)
{
    int period = 0;
    GIE = 0; // disable all unmasked interrupts (INTCON reg)
    if(CCP1IF==1) // checks CCP1 interrupt flag
        {
        CCP1IF = 0; // clears interrupt flag
        TMR1 = 0; // resets TMR1
        period = CCPR1/1000; // transfers captured TMR1 value
        // normalize the value (make the number smaller)
        period = period*8; // multiply by the normalized TMR1 timeout
        }
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
}
void main(void)
{
    TRISC = 0x04; // set RC2 to input
    T1CON = 0x30; // 1:8 prescaler, Timer1 off
    CCP1CON = 0x05; // capture mode: every rising edge
    CCP1IE = 1; // enable TMR1/CCP1 match interrupt (PIE1 reg)
    CCP1IF = 0; // reset interrupt flag (PIR1 reg)
    PEIE = 1; // enable all peripheral interrupt (INTCON reg)
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
    TMR1ON = 1; // Turns on Timer1 (T1CON reg)
    for(;;) // foreground routine
    {
    }
}
```


### Example Compare
```c
void interrupt ISR(void)
{
    GIE = 0; // disable all unmasked interrupts (INTCON reg)
    if(CCP1IF==1) // checks CCP1 interrupt flag
    {
        CCP1IF = 0; // clears interrupt flag
        RA0 = RA0^1; // toggles the output signal at RA0
    }
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
}

void main(void)
{
    ADCON1 = 0x6; // set all pins in PORTA as digital I/O
    TRISA = 0x00; // sets all of PORTA to output
    RA0 = 0; // initialize RA0 to 0
    T1CON = 0x20; // 1:4 prescaler, Timer1 off
    CCP1CON = 0x0A; // compare mode: generate interrupt on match
    CCP1IE = 1; // enable TMR1/CCP1 match interrupt (PIE1 reg)
    CCP1IF = 0; // reset interrupt flag (PIR1 reg)
    CCPR1 = 0x4E2; // set the match value to TMR1
    PEIE = 1; // enable all peripheral interrupt (INTCON reg)
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
    TMR1ON = 1; // Turns on Timer1 (T1CON reg)
    for(;;) // foreground routine
    {
    }
}
```

### Example PWM
```c
void main(void)
{
    /* following the steps in setting up PWM */
    PR2 = 0x7C; // set value for PR2
    CCPR1L = 0x57; // set value for (8 MSBs)
    CCP1CON = 0x2C; // set value for (2 LSBs), PWM mode
    TRISC = 0x00; // sets all of PORTC (RC2) to output
    RC2 = 0; // initialize RC2 to 0
    T2CON = 0x06; // 1:16 prescaler, Timer2 on
    for(;;) // foreground routine
    {
    }
}
```

# Analog To Digital Converter
- AD conversion is the process of converting continously varying signal such as voltage or current into discrete digital quantities that represent the magnitude of the signal compared to a standard or reference voltage

## Conversion Methods
- Flash
    - uses multiple comparators in parallel
    - if analog signal is higher than the known signal, the output of the comparator goes to 1
- Integrating
    - this A/D converter type charges a capacitor for a given amount of time using the analog signal
    - discharges back to zero with a known voltage and the counter provides the value of the unknown signal


### Example A/D Module
```c
int readADC(void)
{
    int temp = 0;
    delay(1000); // delay before reading value
    GO = 1; // start A/D conversion (ADCON0 reg)
    while(GO_DONE==1); // wait until conversion is done (ADCON0 reg)
    /* read result register */
    temp = ADRESH; // read ADRESH
    temp = temp << 8; // move to correct position
    temp = temp | ADRESL; // read ADRESL
    return temp;
}
void delay(int cnt)
{
    while(cnt--);
}

void main(void)
{
    int d_value = 0;
    TRISB = 0x00; // set all PORTB as output
    PORTB = 0X00; // all LEDs OFF
    ADCON1 = 0x80; // result register: right justified, clock: FOSC/2
    // all ports in PORTA are analog
    // VREF+=VDD, VREF-=VSS
    ADCON0 = 0x01; // clock: FOSC/2, analog channel: AN0
    // A/D conversion: STOP, A/D module: ON
    for(;;) // foreground routine
    {
        d_value = readADC();
        /* setting the LEDs */
        if(d_value>=0 && d_value<=169)
        PORTB = 0x00; // all LEDs OFF
        else if(d_value>=170 && d_value<=340)
        PORTB = 0x01; // RB0 LED ON
        ...
        ...
    }
}
```

### ADC with Interrupt
```c
void interrupt ISR(void)
{
    int d_value = 0;
    GIE = 0; // disable all unmasked interrupts (INTCON reg)
    if(ADIF==1) // checks CCP1 interrupt flag
    {
        ADIF = 0; // clears interrupt flag (INTCON reg)
        /* read result register */
        d_value = ADRESH; // read ADRESH
        d_value = d_value << 8; // move to correct position
        d_value = d_value | ADRESL; // read ADRESL
        /* setting the LEDs */
        if(d_value>=0 && d_value<=169)
        PORTB = 0x00; // all LEDs OFF
        else if(d_value>=170 && d_value<=340)
        PORTB = 0x01; // RB0 LED ON
        ...
        ...
    }
    GO = 1; // restart A/D conversion (ADCON0 reg)
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
}


void main(void)
{
    TRISB = 0x00; // set all PORTB as output
    PORTB = 0x00; // all LEDs OFF
    ADCON1 = 0x80; // result register: right Justified, clock: FOSC/8
    // all ports in PORTA are analog
    // VREF+=VDD, VREF-=VSS
    ADCON0 = 0x41; // clock: FOSC/8 analog channel: AN0
    // A/D conversion: STOP, A/D module: ON
    ADIE = 1; // A/D conversion complete interrupt enable (PIE1 reg)
    ADIF = 0; // reset interrupt flag (PIR1 reg)
    PEIE = 1; // enable all peripheral interrupt (INTCON reg)
    GIE = 1; // enable all unmasked interrupts (INTCON reg)
    GO = 1; // start A/D conversion (ADCON0 reg)
    for(;;) // foreground routine
    {
    }
}

```